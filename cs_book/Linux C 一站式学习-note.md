## 结构体

根据语法规则由基本类型组合而成类型称为复合类型(Compound Type)

结构体成员使用.运算符访问

对结构体成员进行初始化过程中，如果initializer中的数据比结构体中多，编译器会报错，如果比结构体中少，未指定的成员将使用０来初始化

结构体变量之间可以使用赋值运算符，用一个结构体变量初始化另一个结构体变量也是允许的，值得注意的是初始化变量必须是局部变量才能进行初始化

结构体可当做函数的参数和返回值来传递

enum关键字（Enumeration）枚举类型 

枚举类型的成员是常量，值由编译器自动分配,从0开始.

## 数组

定义一个由四个结构体组成的数组:

```c
struct complex_struct{

double x,y;

}a[4];
```

五种后缀运算符:后缀++,后缀--,结构体成员.,数组取下标[],函数调用.

五种单目运算符(前缀运算符):前缀++,前缀--,正号,负号,逻辑非!,

c语言中后缀运算符优先级最高,单目运算符优先级次之,比其他运算符优先级都高

数组不能相互赋值,也就不能用数组类型作为函数的参数或返回值

对于数组类型的一条特殊规则:数组类型做右值使用时,自动转换成指向数组首元素的指针

```shell
gcc -E main.c	
```

gcc的-E选项可以看到预处理之后,编译之前的程序,用`cpp main.c`也可以到达同样的效果,`cpp`表示C preprocessor.

printf从数组str的开头一直打印到Null字符为止,Null字符本身是Non-printable字符,不打印.这其实是一个危险的信号,如果数组str没有Null字符,那么printf函数就会访问数组越界,后果可能很诡异.有时候乱码,有时候看起来没错误,有时候引起程序崩溃.

数据驱动的编程:写代码最重要的是选择正确的数据结构来组织信息,设计控制流程和算法尚在其次,只要数据结构选定正确,其他代码自然而然就变得容易维护和理解.

[^2019.11.21]: 

## 9.编码风格

Linux内核 CodingStyle

1.缩进和空白

- 关键词'if','while','for'与其后的控制表达式括号之间插入一个空格分隔
- 双目运算符的两侧各插入一个空格分隔,单目运算符和操作数之间不加空格
- ,号和;之后要加空格,这是英文的书写习惯(for表达式)
- UNIX系统标准字符终端是24行80列,接近或者大于80个字符的较长语句要折行写,折行后要和上行对齐
- 较长的字符串可以断成多个字符串然后分行书写
- 使用tab缩进体现层次关系
- 'if/else','while','do/while','for','switch'等带语句块的语句,语句块的{或}应该和关键字写在同一行,用空格分开(自己习惯单独占一行)
- 函数定义的{和}单独占一行(这一点倒是和我一样)
- switch和语句里的case,default对齐写
- 代码中每个逻辑段落之间应该用一个空行分隔开,例如函数定义之间应该插入一空行,头文件,全局变量定义和函数定义之间也应该插入空行
- 函数语句列表如果很长,可根据相关性分成若干组,用空行分隔,此规定不是硬性要求,通常把变量定义组成一组,后面加空行,return语句之前加空行

2. 注释

   单行注释应采用/* 注释 */的形式,用空格把界定符和文字分开,多行注释多采用如下形式

   ```c
   /*
    *注释语句
    *注释语句         
    * /
   ```

   注释场合分为以下几种

   1. 整个源文件的顶部注释,说明模块信息,文件名,作者,版本历史等,顶头不缩进
   2. 函数注释,说明函数功能,参数,返回值,错误码等,函数定义上侧,函数之间不留空行,顶头写不缩进
   3. 相对独立的语句组注释,对这一组语句做特别说明,写在语句组上侧,语句组之间不留空格,与当前语句组缩进一致
   4. 代码行右侧的简短注释,一般为单行注释,和代码之间至少一个空格隔开,一个文件中所有单行注释最好能够上下对齐.  函数内的注释尽量少用.写注释是为了说明代码能做什么,而不是说明怎么做,只要代码结构清晰,怎么做是一目了然的.
   5. 复杂的结构体比函数更需要注释
   6. 复杂的宏定义和变量声明也需要注释

   3.标识符命名

   1. 标识符命名要清晰明了,可使用完整的单词和易于理解的缩写.
   2. 内核编码规定变量,函数和类型采用全小写加下划线的方式命名,常量(宏定义和枚举常量)采用全大写加下划线的方式命名
   3. 全局变量和全局函数的命名一定要详细,不惜多用几个单词多写几个下划线

   4.函数

   1. 一个函数做好一件事情
   2. 函数内部缩进层次不宜太多,一般少于4层为宜
   3. 函数不要写的太长,24行终端不超过两屏
   4. 执行函数就是执行一个动作,函数名通常应包含动词
   5. 比较重要的函数定义上侧必须加注释,说明函数的功能,参数和返回值
   6. 度量函数复杂度的方法是看有多少局部变量,5-10个就已经够多了

   5.indent工具

   'indent'工具可以把代码格式化为某种风格

   ```shell
   indent -kr -i8 main.c				
   ```

   `-kr`选项 表示K&R风格,`-i8`表示缩进8个空格的长度

## 10.gdb

```shell
gcc -g main.c -o main	
gcc main 
```

编译时加上`-g`选项,生成的可执行文件可以用gdb进行源码级调试

在`(gdb)` 下直接敲回车表示重复上一条命令

`list(l)`列出源代码,接着上次的位置往下列,每次列出10行

`start`命令执行程序,`next(n)`控制语句一条一条地执行

`step(s)`钻进函数去跟踪执行,`backtrace(bt)`查看函数调用栈帧

`info(i)`命令查看函数局部值,`frame(f)`命令选择栈帧查看局部变量

`print(p)`命令打印变量的值

`finish`命令让程序一直运行到从当前函数返回为止

`set var `修改变量的值

`quit(q)`退出gdb调试环境

**断点** 

`break(b) 行号` 在某一行设置断点

`break 函数名`从某个函数开头设置断点

`break... if ...`设置条件断点

`continue(c)` 从当前位置开始继续运行程序

`delete breakpoint 断点号`删除断点

`display 变量名` 跟踪查看某个变量,每次停下来显示它的值

`enble 断点号`启用断点

`info(i) breakpoint` 查看当前设置了哪些断点

`run(r)` 从头开始连续运行程序

`undisplay 跟踪显示号`取消跟踪显示

**观察点**

`watch` 设置观察点

`info(i) watchpoint` 查看当前设置了哪些观察点 

`x` 从某个位置打印储存单元的内容,全部当成字节来看

**段错误**

一条规律:如果某个函数的局部变量发生访问越界,有可能并不立即产生段错误,而是在函数返回时产生段错误.

## 11.排序与查找

**插入排序**：类似于打扑克牌，每拿一张牌都要插入到手中已有的牌里

**归并排序**：首先将序列平均分成两个子序列，分别是`start:mid`和`mid:end`,对这两个子序列分别递归调用归并排序,最后将排好序的两个子序列合并.算法复杂度：`O(nlgn)`

[^2019.11.26]: 

## 12.栈与队列

`while(!is_empty())`　防止操作访问越界

八皇后问题

深度优先搜索解决迷宫问题

广度优先搜索

环形队列

## 13.阶段总结



## 部分II.C语言本质

## 14.计算机中数的表示

如果赋值或者初始化时等号两边的类型不相同,则编译器会把等号右边的类型转换成等号左边的类型再赋值,此章多为跨平台移植开发知识.

[^2019.11.27]: 

## 15.数据类型详解



## 16.运算符详解

按位与`&`	按位或`|`　按位取反`~`　按位异或`^` 	移位`<<`:最高位移除，最低位补零

**掩码**：对特定位操作，与掩码进行与或操作

和０做异或保持原值不变，和１做异或操作得到原值的相反值

如果`a1^a2^a3...^a4`的结果是１，则表示`a1^a2^a3...^a4`之中１的个数为奇数个，否则为偶数个，这条性质用于奇偶检验．

[^2019.11.28]: 

## 17.计算机体系结构基础

待

## 18.x86汇编程序基础

待

## 19.汇编与C之间的关系

待

结构体和联合体的区别(面试问到过)

编写程序测试运行它的平台是大端还是小端(代码实现)

## 20.链接详解

`extern`关键字表示这个标识符具有External Linkage.

`static`关键字修饰一个函数声明，则表示该标识符具有Internal Linkage

注意：变量声明和函数声明有一点不同，函数声明的`extern`可写可不写，而变量声明如果不写`extern`意思就完全变了

在一个模块中，有些函数提供给外部使用，也称导出(Export)给外界使用，这些函数声明为External Linkage的，有些函数只在模块内部使用而不希望被外界访问到，则声明为Internal Linkage的

自己写头文件，在`main.c`中只需要包含这个头文件就可以了，　`# include"xxxx.h"`

对于用对于用角括号包含的头文件，　`gcc`首先查找 `-I`选项指定的目录，然后查找系统的头文件目录；而对于用引号包含的头文件， `gcc`首先查找包含头文件的 `.c`文件所在的目录，然后查找 `-I`选项指定的目录，然后查找系统的头文件目录

宏定义预处理,如下：如果 `STACK_H`这个宏没有定义过，那么从 `#ifndef`到 `#endif`之间的输出代码就包含在预处理的输出结果中，否则这一段代码就不出现在预处理的输出结果中

```c
#ifndef XXX.h
#define STACK_H
extern xxx
extern xxx
#endif	
```

​	**静态库**

```shell
ar rs lib.a obj1.o obj2.o obj3.o	//生成静态库
```

库文件名都以 `lib`开头，静态库以 `.a`作为后缀，表示Archive. `ar`命令类似于 `tar`命令，起一个打包的作用，但是把目标文件打包成静态库只能用 `ar`命令，选项 `r`表示将后面的文件列表添加到文件包， `s`是专用于生成静态库的

**链接共享库和链接静态库区别**：链接共享库只是指定了动态链接器和该程序所需要的库文件，并没有真正做链接，可执行文件中调用的库函数仍然是未定义符号，要在运行时做动态链接，而在链接静态库时，连接器会把静态库中的目标文件取出来和可执行文件真正链接在一起．

(本章挑部分看的，有待补充)

[^2019.11.30]: 



##  21.预处理



