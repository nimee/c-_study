## 结构体

根据语法规则由基本类型组合而成类型称为复合类型(Compound Type)

结构体成员使用.运算符访问

对结构体成员进行初始化过程中，如果initializer中的数据比结构体中多，编译器会报错，如果比结构体中少，未指定的成员将使用０来初始化

结构体变量之间可以使用赋值运算符，用一个结构体变量初始化另一个结构体变量也是允许的，值得注意的是初始化变量必须是局部变量才能进行初始化

结构体可当做函数的参数和返回值来传递

enum关键字（Enumeration）枚举类型 

枚举类型的成员是常量，值由编译器自动分配,从0开始.

## 数组

定义一个由四个结构体组成的数组:

```c
struct complex_struct{

double x,y;

}a[4];
```

五种后缀运算符:后缀++,后缀--,结构体成员.,数组取下标[],函数调用.

五种单目运算符(前缀运算符):前缀++,前缀--,正号,负号,逻辑非!,

c语言中后缀运算符优先级最高,单目运算符优先级次之,比其他运算符优先级都高

数组不能相互赋值,也就不能用数组类型作为函数的参数或返回值

对于数组类型的一条特殊规则:数组类型做右值使用时,自动转换成指向数组首元素的指针

```shell
gcc -E main.c	
```

gcc的-E选项可以看到预处理之后,编译之前的程序,用`cpp main.c`也可以到达同样的效果,`cpp`表示C preprocessor.

printf从数组str的开头一直打印到Null字符为止,Null字符本身是Non-printable字符,不打印.这其实是一个危险的信号,如果数组str没有Null字符,那么printf函数就会访问数组越界,后果可能很诡异.有时候乱码,有时候看起来没错误,有时候引起程序崩溃.

数据驱动的编程:写代码最重要的是选择正确的数据结构来组织信息,设计控制流程和算法尚在其次,只要数据结构选定正确,其他代码自然而然就变得容易维护和理解.

[^2019.11.21]: 

## 9.编码风格

Linux内核 CodingStyle

1.缩进和空白

- 关键词'if','while','for'与其后的控制表达式括号之间插入一个空格分隔
- 双目运算符的两侧各插入一个空格分隔,单目运算符和操作数之间不加空格
- ,号和;之后要加空格,这是英文的书写习惯(for表达式)
- UNIX系统标准字符终端是24行80列,接近或者大于80个字符的较长语句要折行写,折行后要和上行对齐
- 较长的字符串可以断成多个字符串然后分行书写
- 使用tab缩进体现层次关系
- 'if/else','while','do/while','for','switch'等带语句块的语句,语句块的{或}应该和关键字写在同一行,用空格分开(自己习惯单独占一行)
- 函数定义的{和}单独占一行(这一点倒是和我一样)
- switch和语句里的case,default对齐写
- 代码中每个逻辑段落之间应该用一个空行分隔开,例如函数定义之间应该插入一空行,头文件,全局变量定义和函数定义之间也应该插入空行
- 函数语句列表如果很长,可根据相关性分成若干组,用空行分隔,此规定不是硬性要求,通常把变量定义组成一组,后面加空行,return语句之前加空行

2. 注释

   单行注释应采用/* 注释 */的形式,用空格把界定符和文字分开,多行注释多采用如下形式

   ```c
   /*
    *注释语句
    *注释语句         
    * /
   ```

   注释场合分为以下几种

   1. 整个源文件的顶部注释,说明模块信息,文件名,作者,版本历史等,顶头不缩进
   2. 函数注释,说明函数功能,参数,返回值,错误码等,函数定义上侧,函数之间不留空行,顶头写不缩进
   3. 相对独立的语句组注释,对这一组语句做特别说明,写在语句组上侧,语句组之间不留空格,与当前语句组缩进一致
   4. 代码行右侧的简短注释,一般为单行注释,和代码之间至少一个空格隔开,一个文件中所有单行注释最好能够上下对齐.  函数内的注释尽量少用.写注释是为了说明代码能做什么,而不是说明怎么做,只要代码结构清晰,怎么做是一目了然的.
   5. 复杂的结构体比函数更需要注释
   6. 复杂的宏定义和变量声明也需要注释

   3.标识符命名

   1. 标识符命名要清晰明了,可使用完整的单词和易于理解的缩写.
   2. 内核编码规定变量,函数和类型采用全小写加下划线的方式命名,常量(宏定义和枚举常量)采用全大写加下划线的方式命名
   3. 全局变量和全局函数的命名一定要详细,不惜多用几个单词多写几个下划线

   4.函数

   1. 一个函数做好一件事情
   2. 函数内部缩进层次不宜太多,一般少于4层为宜
   3. 函数不要写的太长,24行终端不超过两屏
   4. 执行函数就是执行一个动作,函数名通常应包含动词
   5. 比较重要的函数定义上侧必须加注释,说明函数的功能,参数和返回值
   6. 度量函数复杂度的方法是看有多少局部变量,5-10个就已经够多了

   5.indent工具

   'indent'工具可以把代码格式化为某种风格

   ```shell
   indent -kr -i8 main.c				
   ```

   `-kr`选项 表示K&R风格,`-i8`表示缩进8个空格的长度

## 10.gdb

```shell
gcc -g main.c -o main	
gcc main 
```

编译时加上`-g`选项,生成的可执行文件可以用gdb进行源码级调试

在`(gdb)` 下直接敲回车表示重复上一条命令

`list(l)`列出源代码,接着上次的位置往下列,每次列出10行

`start`命令执行程序,`next(n)`控制语句一条一条地执行

`step(s)`钻进函数去跟踪执行,`backtrace(bt)`查看函数调用栈帧

`info(i)`命令查看函数局部值,`frame(f)`命令选择栈帧查看局部变量

`print(p)`命令打印变量的值

`finish`命令让程序一直运行到从当前函数返回为止

`set var `修改变量的值

`quit(q)`退出gdb调试环境

**断点** 

`break(b) 行号` 在某一行设置断点

`break 函数名`从某个函数开头设置断点

`break... if ...`设置条件断点

`continue(c)` 从当前位置开始继续运行程序

`delete breakpoint 断点号`删除断点

`display 变量名` 跟踪查看某个变量,每次停下来显示它的值

`enble 断点号`启用断点

`info(i) breakpoint` 查看当前设置了哪些断点

`run(r)` 从头开始连续运行程序

`undisplay 跟踪显示号`取消跟踪显示

**观察点**

`watch` 设置观察点

`info(i) watchpoint` 查看当前设置了哪些观察点 

`x` 从某个位置打印储存单元的内容,全部当成字节来看

**段错误**

一条规律:如果某个函数的局部变量发生访问越界,有可能并不立即产生段错误,而是在函数返回时产生段错误.

## 11.排序与查找

**插入排序**：类似于打扑克牌，每拿一张牌都要插入到手中已有的牌里

**归并排序**：首先将序列平均分成两个子序列，分别是`start:mid`和`mid:end`,对这两个子序列分别递归调用归并排序,最后将排好序的两个子序列合并.算法复杂度：`O(nlgn)`

[^2019.11.26]: 

## 12.栈与队列

`while(!is_empty())`　防止操作访问越界

八皇后问题

深度优先搜索解决迷宫问题

广度优先搜索

环形队列

## 13.阶段总结



## 部分II.C语言本质

## 14.计算机中数的表示

如果赋值或者初始化时等号两边的类型不相同,则编译器会把等号右边的类型转换成等号左边的类型再赋值,此章多为跨平台移植开发知识.

[^2019.11.27]: 

## 15.数据类型详解



## 16.运算符详解

按位与`&`	按位或`|`　按位取反`~`　按位异或`^` 	移位`<<`:最高位移除，最低位补零

**掩码**：对特定位操作，与掩码进行与或操作

和０做异或保持原值不变，和１做异或操作得到原值的相反值

如果`a1^a2^a3...^a4`的结果是１，则表示`a1^a2^a3...^a4`之中１的个数为奇数个，否则为偶数个，这条性质用于奇偶检验．

[^2019.11.28]: 

## 17.计算机体系结构基础

