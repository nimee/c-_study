## 1.算法概述

递归的空间复杂度:递归的深度为n,空间复杂度为O(n)

算法:在计算机领域里,算法是一系列程序指令,用于处理特定的运算和逻辑问题

数据结构:数据结构是数据的组织,管理和存储方式,其目的是为了高效地访问和修改数据

## 2.数据结构基础

**链表插入节点**

尾部插入：把最后一个节点的next指针指向新插入的节点即可

头部插入：1.把新节点的next指针指向原先的头结点,2.把新节点变为链表的头结点

中间插入：1.新节点的next指针,指向插入位置的节点,2插入位置前置节点的next指针,指向新节点

**循环队列**：假设一个队列经过反复的入队和出队操作，还剩下两个元素，在＂物理＂上分布于数组的末尾位置，这时又有一个新元素将要入队，在数组不做扩容的情况下，可以利用已出队元素留下的空间，让队尾指针重新指向数组的首位．

散列表也叫哈希表，这种数据结构提供了**键**和**值**的映射关系，只要给出一个key,就可以高效查找它所匹配的value,时间复杂度接近于 `O(1)`.

**哈希冲突**：两个或者多个key对应的数组下标相同.

解决哈希冲突的方法：一种是开放寻址法，一种是链表法

开放寻址法：当一个key通过哈希函数获得对应的数组下标已经被占用时，寻找下一空挡位置．

链表法：HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头结点.每一个Entry对象通过next指针指向它的下一个Entry节点，当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可．

[^2019.11.25]: 

## 3.树

树是`n(n>=0)`个节点的有限集当`n=0`时，称为空树，在任意一个非空树中，有如下特点：

- 有且仅有一个特定的称为根的节点
- 当`N>=1`时，其余节点可分为`m(m>0)`个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树

**二叉树**

二叉树是数的一种特殊形式，二叉，这种树的每个节点最多有２个孩子节点，一个称为左孩子，一个称为右孩子．

**满二叉树**：一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树，简单点说，满二叉树的每一个分支都是满的

**完全二叉树**：对一个有`n`个节点的二叉树，按层级顺序编号，则所有节点的编号为从１到`n`，如果这个树所有节点和同样深度的满二叉树的编号为从１到`n`的节点位置相同，则这个二叉树为完全二叉树．

完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可

**二叉查找树**:

- 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
- 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
- 左右子树也都是二叉查找树

二叉树自平衡方：红黑树，AVL树，树堆

**二叉树遍历**

**深度优先遍历**:前序遍历,中序遍历,后	序遍历, **广度优先遍历**:层序遍历

前序遍历:输出顺序是根节点,左子树,右子树

中序遍历:输出顺序是坐子树,根节点,右子树

后序遍历:输出顺序是左子树,右子树,根节点

**三种遍历方式代码实现***(递归或者遍历)

广度优先遍历即层序遍历,通过队列实现

**二叉堆**

本质上是一种完全二叉树,分为最大堆和最小堆

最大堆:任何一个父节点的值都大于或等于它左右孩子节点的值

最小堆:任何一个父节点的值都小于或等于它左右孩子节点的值

二叉堆的根节点叫做堆顶,最大堆和最小堆的特点决定了堆顶是最大元素还是最小元素

**二叉堆**的操作:**插入节点,删除节点,构建二叉堆**

插入节点:插入位置是完全二叉树的最后一个位置,...

删除节点:删除的是处于堆顶的节点.

构建二叉堆:从最后一个非叶子节点开始,逐次往上

二叉堆的所有节点存储在数组中,节点的计算方式可以计算为:假设父节点的下标是`parent`,那么它的左孩子节点下标为`2*parent+1`,右孩子节点下标就是`2*parent+2`.	

**构建二叉堆(二叉堆调整)代码实现**

**优先队列**:用最大堆实现最大优先队列,这样的话,每一次入队操作就是堆的插入操作,每一次出队操作就是删除堆顶节点

[^2019.11.27]: 

## 4.排序算法

